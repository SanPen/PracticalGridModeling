%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% How to use writeLaTeX: 
%
% You edit the source code here on the left, and the preview on thes
% right shows you the result within a few seconds.
%
% Bookmark this page and share the URL with your co-authors. They can
% edit at the same time!
%
% You can upload figures, bibliographies, custom classes and
% styles using the files menu.
%
% If you're new to LaTeX, the wikibook is a great place to start:
% http://en.wikibooks.org/wiki/LaTeX
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass{tufte-book}

\usepackage[
    type={CC},
    modifier={by-sa},
    version={3.0},
]{doclicense}

\hypersetup{colorlinks}% uncomment this line if you prefer colored hyperlinks (e.g., for onscreen viewing)

%%
% Book metadata
\title{Practical Grid\\Modelling}
\author[]{Santiago Pe\~nate Vera}
\publisher{}

%%
% If they're installed, use Bergamo and Chantilly from www.fontsite.com.
% They're clones of Bembo and Gill Sans, respectively.
%\IfFileExists{bergamo.sty}{\usepackage[osf]{bergamo}}{}% Bembo
%\IfFileExists{chantill.sty}{\usepackage{chantill}}{}% Gill Sans

%\usepackage{microtype}

%%
% Just some sample text
\usepackage{lipsum}

%%
% For nicely typeset tabular material
\usepackage{booktabs}

%%
% For graphics / images
\usepackage{graphicx}
\setkeys{Gin}{width=\linewidth,totalheight=\textheight,keepaspectratio}
\graphicspath{{graphics/}}

% The fancyvrb package lets us customize the formatting of verbatim
% environments.  We use a slightly smaller font.
\usepackage{fancyvrb}
\fvset{fontsize=\normalsize}

%%
% Prints argument within hanging parentheses (i.e., parentheses that take
% up no horizontal space).  Useful in tabular environments.
\newcommand{\hangp}[1]{\makebox[0pt][r]{(}#1\makebox[0pt][l]{)}}

%%
% Prints an asterisk that takes up no horizontal space.
% Useful in tabular environments.
\newcommand{\hangstar}{\makebox[0pt][l]{*}}

%%
% Prints a trailing space in a smart way.
\usepackage{xspace}

%%
% Some shortcuts for Tufte's book titles.  The lowercase commands will
% produce the initials of the book title in italics.  The all-caps commands
% will print out the full title of the book in italics.
\newcommand{\vdqi}{\textit{VDQI}\xspace}
\newcommand{\ei}{\textit{EI}\xspace}
\newcommand{\ve}{\textit{VE}\xspace}
\newcommand{\be}{\textit{BE}\xspace}
\newcommand{\VDQI}{\textit{The Visual Display of Quantitative Information}\xspace}
\newcommand{\EI}{\textit{Envisioning Information}\xspace}
\newcommand{\VE}{\textit{Visual Explanations}\xspace}
\newcommand{\BE}{\textit{Beautiful Evidence}\xspace}

\newcommand{\TL}{Tufte-\LaTeX\xspace}

% Prints the month name (e.g., January) and the year (e.g., 2008)
\newcommand{\monthyear}{%
  \ifcase\month\or January\or February\or March\or April\or May\or June\or
  July\or August\or September\or October\or November\or
  December\fi\space\number\year
}


% Prints an epigraph and speaker in sans serif, all-caps type.
\newcommand{\openepigraph}[2]{%
  %\sffamily\fontsize{14}{16}\selectfont
  \begin{fullwidth}
  \sffamily\large
  \begin{doublespace}
  \noindent\allcaps{#1}\\% epigraph
  \noindent\allcaps{#2}% author
  \end{doublespace}
  \end{fullwidth}
}

% Inserts a blank page
\newcommand{\blankpage}{\newpage\hbox{}\thispagestyle{empty}\newpage}

\usepackage{units}

% Typesets the font size, leading, and measure in the form of 10/12x26 pc.
\newcommand{\measure}[3]{#1/#2$\times$\unit[#3]{pc}}

% Macros for typesetting the documentation
\newcommand{\hlred}[1]{\textcolor{Maroon}{#1}}% prints in red
\newcommand{\hangleft}[1]{\makebox[0pt][r]{#1}}
\newcommand{\hairsp}{\hspace{1pt}}% hair space
\newcommand{\hquad}{\hskip0.5em\relax}% half quad space
\newcommand{\TODO}{\textcolor{red}{\bf TODO!}\xspace}
\newcommand{\ie}{\textit{i.\hairsp{}e.}\xspace}
\newcommand{\eg}{\textit{e.\hairsp{}g.}\xspace}
\newcommand{\na}{\quad--}% used in tables for N/A cells
\providecommand{\XeLaTeX}{X\lower.5ex\hbox{\kern-0.15em\reflectbox{E}}\kern-0.1em\LaTeX}
\newcommand{\tXeLaTeX}{\XeLaTeX\index{XeLaTeX@\protect\XeLaTeX}}
% \index{\texttt{\textbackslash xyz}@\hangleft{\texttt{\textbackslash}}\texttt{xyz}}
\newcommand{\tuftebs}{\symbol{'134}}% a backslash in tt type in OT1/T1
\newcommand{\doccmdnoindex}[2][]{\texttt{\tuftebs#2}}% command name -- adds backslash automatically (and doesn't add cmd to the index)
\newcommand{\doccmddef}[2][]{%
  \hlred{\texttt{\tuftebs#2}}\label{cmd:#2}%
  \ifthenelse{\isempty{#1}}%
    {% add the command to the index
      \index{#2 command@\protect\hangleft{\texttt{\tuftebs}}\texttt{#2}}% command name
    }%
    {% add the command and package to the index
      \index{#2 command@\protect\hangleft{\texttt{\tuftebs}}\texttt{#2} (\texttt{#1} package)}% command name
      \index{#1 package@\texttt{#1} package}\index{packages!#1@\texttt{#1}}% package name
    }%
}% command name -- adds backslash automatically
\newcommand{\doccmd}[2][]{%
  \texttt{\tuftebs#2}%
  \ifthenelse{\isempty{#1}}%
    {% add the command to the index
      \index{#2 command@\protect\hangleft{\texttt{\tuftebs}}\texttt{#2}}% command name
    }%
    {% add the command and package to the index
      \index{#2 command@\protect\hangleft{\texttt{\tuftebs}}\texttt{#2} (\texttt{#1} package)}% command name
      \index{#1 package@\texttt{#1} package}\index{packages!#1@\texttt{#1}}% package name
    }%
}% command name -- adds backslash automatically
\newcommand{\docopt}[1]{\ensuremath{\langle}\textrm{\textit{#1}}\ensuremath{\rangle}}% optional command argument
\newcommand{\docarg}[1]{\textrm{\textit{#1}}}% (required) command argument
\newenvironment{docspec}{\begin{quotation}\ttfamily\parskip0pt\parindent0pt\ignorespaces}{\end{quotation}}% command specification environment
\newcommand{\docenv}[1]{\texttt{#1}\index{#1 environment@\texttt{#1} environment}\index{environments!#1@\texttt{#1}}}% environment name
\newcommand{\docenvdef}[1]{\hlred{\texttt{#1}}\label{env:#1}\index{#1 environment@\texttt{#1} environment}\index{environments!#1@\texttt{#1}}}% environment name
\newcommand{\docpkg}[1]{\texttt{#1}\index{#1 package@\texttt{#1} package}\index{packages!#1@\texttt{#1}}}% package name
\newcommand{\doccls}[1]{\texttt{#1}}% document class name
\newcommand{\docclsopt}[1]{\texttt{#1}\index{#1 class option@\texttt{#1} class option}\index{class options!#1@\texttt{#1}}}% document class option name
\newcommand{\docclsoptdef}[1]{\hlred{\texttt{#1}}\label{clsopt:#1}\index{#1 class option@\texttt{#1} class option}\index{class options!#1@\texttt{#1}}}% document class option name defined
\newcommand{\docmsg}[2]{\bigskip\begin{fullwidth}\noindent\ttfamily#1\end{fullwidth}\medskip\par\noindent#2}
\newcommand{\docfilehook}[2]{\texttt{#1}\index{file hooks!#2}\index{#1@\texttt{#1}}}
\newcommand{\doccounter}[1]{\texttt{#1}\index{#1 counter@\texttt{#1} counter}}

% Generates the index
\usepackage{makeidx}
\makeindex




\begin{document}

% Front matter
\frontmatter

% r.1 blank page
%\blankpage

% v.2 epigraphs
%\newpage\thispagestyle{empty}
%\openepigraph{%
%The public is more familiar with bad design than good design.
%It is, in effect, conditioned to prefer bad design, 
%because that is what it lives with. 
%The new becomes threatening, the old reassuring.
%}{Paul Rand%, {\itshape Design, Form, and Chaos}
%}
%\vfill
%\openepigraph{%
%A designer knows that he has achieved perfection 
%not when there is nothing left to add, 
%but when there is nothing left to take away.
%}{Antoine de Saint-Exup\'{e}ry}
%\vfill
%\openepigraph{%
%\ldots the designer of a new system must not only be the implementor and the first 
%large-scale user; the designer should also write the first user manual\ldots 
%If I had not participated fully in all these activities, 
%literally hundreds of improvements would never have been made, 
%because I would never have thought of them or perceived 
%why they were important.
%}{Donald E. Knuth}


% r.3 full title page
\maketitle

\doclicenseThis

% v.4 copyright page
\newpage
%\begin{fullwidth}
%~\vfill
%\thispagestyle{empty}
%\setlength{\parindent}{0pt}
%\setlength{\parskip}{\baselineskip}
%Copyright \copyright\ \the\year\ \thanklessauthor
%
%\par\smallcaps{Published by \thanklesspublisher}
%
%\par\smallcaps{tufte-latex.googlecode.com}
%
%\par Licensed under the Apache License, Version 2.0 (the ``License''); you may not
%use this file except in compliance with the License. You may obtain a copy
%of the License at \url{http://www.apache.org/licenses/LICENSE-2.0}. Unless
%required by applicable law or agreed to in writing, software distributed
%under the License is distributed on an \smallcaps{``AS IS'' BASIS, WITHOUT
%WARRANTIES OR CONDITIONS OF ANY KIND}, either express or implied. See the
%License for the specific language governing permissions and limitations
%under the License.\index{license}
%
%\par\textit{First printing, \monthyear}
%\end{fullwidth}



% r.5 contents
\tableofcontents

\listoffigures

\listoftables


%-------------------------------------------------------------------------------
%	CHAPTER Introduction
%-------------------------------------------------------------------------------
\chapter{Introduction}

This book aims at explaining grid modelling from a practical perspective, providing state of the art models, algorithms as well as implementation hints and examples.

The goal is to provide a reference document for researchers and computer engineers in the field of electric systems modelling, so that the task of building your own simulator or extend the already available open source ones becomes feasible.

The book assumes that the reader has a basic understanding of matrices, vectors and complex numbers. The notation used in the book is intended to be clear and accessible as much as it is practically possible.

Most of the formulas presented will imply vectorized operations such as matrix multiplications or element-wise multiplications. This notation makes it much easier to implement the numerical methods, and in case of scripting languages such as python, enables the use of fast linear algebra libraries. This is key in the implementation of electrical systems simulators, since most articles and books provide the formulas using summations, which implementation in languages other than c or Fortran would make the simulator prohibitively slow in comparison with the vectorized version.

Vectorized formulas also allow a much simpler debug and maintenance of the produced software.


%-------------------------------------------------------------------------------
%	CHAPTER notation
%-------------------------------------------------------------------------------
\chapter{Notation}

\begin{itemize}

\item $A \times B \rightarrow$ Matrix-Matrix dot product.

\item $A \times b \rightarrow$ Matrix-Vector dot product.

\item $A \cdot B \rightarrow$ Matrix-Matrix element wise multiplication.

\item $a \cdot b \rightarrow$ vector-vector element wise multiplication.

\item $A^{*}\rightarrow$ Element-wise conjugate of the numbers composing $A$.

\item $A^{-1}\rightarrow$ Matrix inverse.

\item $A^{T}\rightarrow$ Transposed matrix or vector.

\item $A^{-1} \times b \rightarrow$ Solve the linear system where $A$ is the coefficients matrix and $b$ is the free terms vector. Never perform the inverse of $A$ and then multiply it by $b$. Instead use a linear system solver.

\item $A[rows, :] \rightarrow$ From the matrix $A$, pick the rows which indices are contained in the vector $rows$.


\item $A[:, cols] \rightarrow$ From the matrix $A$, pick the columns which indices are contained in the vector  $cols$.


\item $A[rows, cols] \rightarrow$ From the matrix $A$, pick the rows which indices are contained in the vector  $rows$ and the columns which indices are contained in the vector  $cols$.


\item $b[rows] \rightarrow$ From the vector $b$, pick the elements contained in the vector or list $rows$.

\item $diag(b) \rightarrow$ Convert the vector $b$ into a diagonal matrix. 

\item $diag(A) \rightarrow$ Extract the diagonal of the matrix $A$ as a vector. 

\item $real(A) \rightarrow$ Extract the real part of $A$.

\item $imag(A) \rightarrow$ Extract the imaginary part of $A$.

\item $max(b) \rightarrow$ Maximum value of the vector $b$.

\item $max(c, d) \rightarrow$ Pick the greater value between $c$ and $d$.
\end{itemize}

%-------------------------------------------------------------------------------
%	CHAPTER General network model
%-------------------------------------------------------------------------------
\chapter{General network model}

The electrical grid can be assimilated to a graph. A graph is a mathematical object composed of nodes and edges (or branches). From a calculation point of view, a node is the place where the voltage is calculated given power and current injections, and a branch is the place where the current and power that flows through it are computed given the nodes voltage.

In the general network model, the the neutral wire and the earth "wire" are embedded into the three-phase equivalent using Kron's reduction. See \cite{dorfler2013kron} for a comprehensive explanation or simply \cite{kersting2012distribution} for practical application.

A node has power injection or consumption devices attached to it. Examples are loads, generators, capacitor banks or any other device that injects or consumes power from the grid.

A branch might have devices attached that modify the flow through the branch. Such devices are known as FACTS (Flexible Alternating Current Transmission Systems). 

A real life grid can be composed of several isolated groups of nodes (islands). It is impossible to calculate magnitudes of several islands at once in the same numerical process. Hence, the maximal calculation object is the island circuit: a graph that does not contain further islands inside. In practice, a grid is split in its islands, each island is computed separately and the results are merged back to provide a consistent analysis interface of the whole grid.

\section{n-phase modeling}

The electrical grid calculations are mostly done in what is called "positive sequence equivalent. This is a single phase equivalent of a three-phase grid. In practice the positive sequence equivalent is applied to branches with one, two or three phases, this simplifies the modelling, but makes the realistic analysis of the grid much harder since the phases imbalance has been neglected.

In this book, three-phase models will be presented, but the aplication of the numerical methods will be done in phase-by-phase basis. This is possible using the models presented by Vieira, Freitas and Morelato \cite{vieira2004phase}. In their work, the authors pick the diagonal of the elements admittance matrices to form single-phase grids, that are simulated independently. The magnetic coupling effects are included in the single-phase admittance matrices as shunt elements. This allows a very flexible model of the grid while retaining the calculation accuracy of a full-blown n-phase admittance matrix.

So, because of the latter, the models will be introduced in three-phases and whenever needed in positive sequence equivalents, but the numerical methods will consider only one phase at the time. In practice we will solve one numerical problem per phase, and when all the phases are simulated, we will merge the results into n-phase structures.

%-------------------------------------------------------------------------------
%	CHAPTER Magnitudes and units
%-------------------------------------------------------------------------------
\chapter{Magnitudes and units}



As the electric energy is mostly distributed in alternating current, electrical magnitudes are waves that vary their polarity (positive and negative value) and amplitude in time. because of this, the electrical magnitudes are expressed by complex numbers to denote the position of the value in the two-dimensional plane amplitude-time. 

\begin{marginfigure}
  \includegraphics[width=\linewidth]{img/VoltageDelay.eps}
  \caption{Voltage delay.}
  \label{fig:vdelay}
\end{marginfigure}


The units in electrical grid modelling are represented in the tables \ref{units_table} and \ref{real_imaginary_table}.


\begin{table}[h]\index{typefaces!sizes}
\begin{center}
\footnotesize
\begin{tabular}{lll}
\toprule
Magnitude & Unit & Recommended user input unit\\
\midrule
Voltage & $V$ (Volt) & $kV$ (kilo-Volt)\\
Current & $A$ (Ampere) & $kA$ (kilo-Ampere)\\
Power & $VA$ (Volt-Ampere) & $MVA$ (Mega-Volt-Ampere)\\
Active power & $W$ (Watt) & $MW$ (Mega-Watt)\\
Reactive power & $VAr$ (Volt-Ampere-reactive) & $MVAr$ (Mega-Volt-Ampere-reactive)\\
Impedance & $\Omega$ (Ohm) & $\Omega$ (Ohm) or per-unit\\
Admittance & $S$ (Siemens) &  $S$ (Siemens) or per-unit\\
\bottomrule
\end{tabular}
\end{center}
  \caption{Electrical magnitudes and their units.}
  \label{units_table}
\end{table}


\begin{marginfigure}
  \includegraphics[width=0.5\linewidth]{img/VoltagePhasors.eps}
  \caption{Voltage delay in phasor representation in the complex plane.}
  \label{fig:vphasors}
\end{marginfigure}


The figure \ref{fig:vdelay} shows two voltage waves. The one represented with a dotted line is delayed an angle $\delta$ with respect to the reference voltage wave represented by the plain black line. Since both waves are periodical, both can be represented as "phasors" or vectors indicating the magnitude's value and angle in the complex rectangular plane as depicted in the figure \ref{fig:vphasors}. Figures \ref{fig:vdelay} and \ref{fig:vphasors} are equivalent representations.


\begin{table}[h]\index{typefaces!sizes}
\begin{center}
\footnotesize
\begin{tabular}{llll}
\toprule
Magnitude & Real part & Imaginary part & Relation\\
\midrule
$S$ (Power) & $P$ (Active power) & $Q$ (Reactive power) & $S=P +jQ$\\
$V$ (Voltage) & $V_r$ (Real voltage) & $V_i$ (Imaginary voltage) & $V=V_r +jV_i$\\
Expressed as  &  &  & \\
 & $V_m$ (Voltage module) &  & \\
 & $\delta$ (Voltage angle) &  & $V = V_m \cdot e^\delta$\\
  &  &  & \\
$I$ (Current) & $I_r$ (Real current) & $I_i$ (Imaginary current) & $I=I_r +jI_i$\\
$Z$ (Impedance) & $R$ (Resistance) & $X$ (Inductance) & $Z=R +jX$\\
$Y$ (Admittance) & $G$ (Conductance) & $B$ (Susceptance) & $Y=G +jB$\\
\bottomrule
\end{tabular}
\end{center}
  \caption{Magnitudes and their real and imaginary complex components.}
  \label{real_imaginary_table}
\end{table}






\section{Components connection and their conversions}

Let us assume a three-phase grid. The phases of the grid are denoted by the names of $A$, $B$ and $C$. There are two main connection types that arise: Wye (like the letter "y") and Delta.

The wye and delta connections provide the ground to introduce the \textit{phase} and \textit{line} voltages. The phase to neutral voltage is called \textit{phase voltage}, those are $V_A$, $V_B$ and $V_C$. The phase to phase voltage is called \textit{line voltage}, those are $V_{AB}$, $V_{AC}$ and $V_{BC}$.

\paragraph{The delta connection} is depicted in the figure \ref{fig:delta}. The delta connection has no neutral.

\paragraph{The wye connection} is depicted in the figure \ref{fig:star}. The star connection does have neutral ($N$). The wye connection is also known as star connection.

\begin{marginfigure}
  \includegraphics[width=0.9\linewidth]{img/Delta.eps}
  \caption{Delta connection scheme.}
  \label{fig:delta}
\end{marginfigure}

\begin{marginfigure}
  \includegraphics[width=0.9\linewidth]{img/Star.eps}
  \caption{Wye connection scheme.}
  \label{fig:star}
\end{marginfigure}

\paragraph{Delta to Wye ($\Delta \rightarrow Y$)} The transformation of a three phase connected shunt element in Delta to it's Wye equivalent is:

\begin{equation}
Elm_{Wye} = D \times Elm_{Delta}
\end{equation}

Where $D$ is:

\begin{equation}
D = \left[ \begin{array}{ccc}
1 & -1 & 0 \\
0 & 1 & -1 \\
-1 & 0 & 1
\end{array} \right]
\end{equation}

For instance, considering the impedances transformation from figures \ref{fig:delta} and \ref{fig:star}:

\begin{equation}
\left[ \begin{array}{c}
Z_A \\
Z_B \\
Z_C
\end{array} \right] = \left[ \begin{array}{ccc}
1 & -1 & 0 \\
0 & 1 & -1 \\
-1 & 0 & 1
\end{array} \right] \times \left[ \begin{array}{c}
Z_{AB} \\
Z_{AC} \\
Z_{BC}
\end{array} \right]
\end{equation}

\paragraph{Wye to Delta ($Y\rightarrow \Delta$)} The transformation of a three phase connected shunt element in Wye to it's Delta equivalent is:

\begin{equation}
Elm_{Delta} = D^{-1} \times Elm_{Wye}
\end{equation}

Where $D^{-1}$ is:

\begin{equation}
D^{-1} = \frac{1}{3} \left[ \begin{array}{ccc}
1 & 0 & -1 \\
-1 & 1 & 0 \\
0 & -1 & 1
\end{array} \right]
\end{equation}

For instance, considering the impedances transformation from figures \ref{fig:delta} and \ref{fig:star}:

\begin{equation}
\left[ \begin{array}{c}
Z_{AB} \\
Z_{AC} \\
Z_{BC}
\end{array} \right] = \frac{1}{3} \left[ \begin{array}{ccc}
1 & 0 & -1 \\
-1 & 1 & 0 \\
0 & -1 & 1
\end{array} \right] \times \left[ \begin{array}{c}
Z_A \\
Z_B \\
Z_C
\end{array} \right]
\end{equation}




\section{Per unit system}

In an electrical grid there are multiple levels of voltage. This situation introduces discontinuities in the numerical methods used to solve power flows and state estimations among others, producing an unstable convergence behaviour. To avoid this, the per unit system is introduced. A side effect of the per unit representation is to have a very convenient way of visualizing the grid magnitudes, all referenced to their base. In the per unit system, all the voltages are expressed in terms of their nominal value. In this case, all the grid voltage values are around one. For instance, a voltage value of 0.98 means that the voltage is 98 \% of the nominal voltage value at that point.

For most exchange formats in computer programs, the element's magnitudes are expressed with a mix of actual units and per unit values. Regardless of this, a practical way of converting any electrical magnitude to its per unit equivalent is presented.

First, we must choose an arbitrary value of power base conversion. This value can be seen as the grid's nominal power, even though that concept is not related to any physical quantity, but it is rather a numerical artifice. 

\marginnote{ The base power is most commonly chosen to be $S_{Base} = 100 MVA$.}




\bigskip
\begin{table}[h!]\index{typefaces!sizes}
\begin{center}
\footnotesize
\begin{tabular}{lll}
\toprule
Magnitude &  Base\\
\midrule
$V$ (Voltage) & $V_{Base}$: terminal's nominal voltage. \\
$S$ (Power) & $S_{Base}$: Arbitrary value. \\
$I$ (Current) & $I_{Base} = S_{Base} / Vline_{Base} = S_{Base} / (V_{Base} \cdot \sqrt{3})$ \\
$Z$ (Impedance) & $Z_{Base} = S_{Base} / V_{Base}^2$ \\
$Y$ (Admittance) & $Y_{Base} = 1 / Z_{Base}$ \\
\bottomrule
\end{tabular}
\end{center}
  \caption{Electrical magnitudes and their per unit base.}
  \label{magnitudes_and_their_base}
\end{table}


\section{Sequence components simplification}

Charles L. Fortescue presented in 1918 his famous article \cite{fortescue1918method} in which he describes how to represent a three-phase element in the so-called \textit{sequence components}.

The main use of this technique is to reduce the amount of impedances needed to represent a line or transformer from usually nine, to three (or even two) if the element is considered to be balanced. An element is considered balance if the impedance in all it's phases is equal and the phase-to-phase coupling impedances are also equal. This is an assumption that is commonly made for transmission grids (very high voltage) and distribution grids in high voltage. This advance allowed the popularization of the single-line diagrams in which every line represents a  a number of wires transmitting power in a balanced scheme.

Fortesue defined a transformation matrix $A_s$ and it's inverse as:

\begin{equation}
A_s = \left[ \begin{array}{ccc}
1 & 1 & 1 \\
1 & a^2 & a \\
1 & a & a^2
\end{array} \right]
\end{equation}

\begin{equation}
A_s^{-1} = \frac{1}{3}\left[ \begin{array}{ccc}
1 & 1 & 1 \\
1 & a & a^2 \\
1 & a^2 & a
\end{array} \right]
\end{equation}

Where $a$ is the transformation eigenvector:
\begin{equation}
a = 1^{120_{deg}} = 1 \cdot e^{j \frac{2}{3}\pi} = 1 \cdot cos\left(\frac{2}{3}\pi\right) + 1j \cdot sin\left(\frac{2}{3}\pi\right)
\end{equation}

\begin{equation}
a^2 = 1^{-120_{deg}} = 1 \cdot e^{-j \frac{2}{3}\pi} = 1 \cdot cos\left(\frac{2}{3}\pi\right) - 1j \cdot sin\left(\frac{2}{3}\pi\right)
\end{equation}


Then, any 3x3 impedance matrix representing the rectangular ABC three-phase impedance of an element (line, transformer, capacitor, etc.) can be transformed to a sequence equivalent using the formula:

\begin{equation}
Z_{seq} = A_s^{-1} \times Z_{ABC} \times A_s
\label{fortescue_transformation}
\end{equation}


\paragraph{Example}

Consider the following impedance matrix of a three-phase line. Example from \cite{kersting2012distribution}.

$$
Z_{ABC} = \left[ \begin{array}{ccc}
0.4576 + j 1.0780 & 0.1560 + j0 .5017 & 0.1535 + j 0.3849 \\
0.1560 + j 0.5017 & 0.4666 + j 1.0482 & 0.1580 + j 0.4236 \\ 
0.1535 + j 0.3849 & 0.1580 + j 0.4236 & 0.4615 + j 1.0651
\end{array} \right]
$$

Using equation \ref{fortescue_transformation}, we obtain the sequence impedance matrix:
$$
Z_{seq} = \left[ \begin{array}{ccc}
0.7735 + j 1.9373  & 0.0256 + j 0.0115 & – 0.0321 + j 0.0159 \\
-0.0321 + j 0.0159 & 0.3061 + j 0.6270 & – 0.0723  –  j 0.0060 \\ 
0.0256  +  j 0.0115 & -0.0723  –  j 0.0059 & 0.3061  +  j 0.6270
\end{array} \right]
$$

For the sequence matrix, the non diagonal elements are neglected. Using only the three diagonal elements as:

$$
\begin{array}{c}
Z_0 = 0.7735 + j 1.9373 \\
Z_1 = 0.3061 + j 0.6270 \\
Z_2 = 0.3061  +  j 0.6270
\end{array}
$$

Observe that $Z_1$ and $Z_2$ are identical (with the shown numerical precision). It is very common in utilities to store only $Z_0$ and $Z_1$ to define a line. The balanced element assumption is very common and should be carefully used.

\section{Building $Z_{ABC}$ from the sequence components}

Once the complete 3x3 impedance matrix has been reduced to the sequence components and only those have been stored in the utility database, the obtaining of the full 3x3 matrix might be necessary to perform unbalanced calculations. Of course we will not be able to obtain the exact original $Z_{ABC}$ from the reduced sequence components, but the approximation is fair.

The approximated full impedance matrix is obtained from the sequence components as:

\begin{equation}
Z_{ABC_{approx}} = \frac{1}{3}\left[ \begin{array}{ccc}
2Z_1 + Z_0 & Z_0 - Z_1 & Z_0 - Z_1 \\
Z_0 - Z_1 & 2Z_1 + Z_0 & Z_0 - Z_1 \\ 
Z_0 - Z_1 & Z_0 - Z_1 & 2Z_1 + Z_0
\end{array} \right]
\end{equation}

\paragraph{Example}

We need to compute two values, before assembling the 3x3 matrix:

$$
\frac{1}{3}(2 \cdot Z_1 + Z_0) = \frac{1}{3} (2\cdot(0.3061 + j 0.6270) + (0.7735 + j 1.9373)) = 0.4619 + j1.0638
$$

$$
\frac{1}{3} (Z_0 - Z_1) = \frac{1}{3}((0.7735 + j 1.9373) - (0.3061 + j 0.6270)) = 0.1558 + j0.4368
$$

The the approximated impedance matrix is:

$$
Z_{ABC_{approx}} = \left[ \begin{array}{ccc}
0.4619 + j1.0638 & 0.1558 + j0.4368 & 0.1558 + j0.4368 \\
0.1558 + j0.4368 & 0.4619 + j1.0638 & 0.1558 + j0.4368 \\ 
0.1558 + j0.4368 & 0.1558 + j0.4368 & 0.4619 + j1.0638
\end{array} \right]
$$

We observe that the calculation outcome is a fair approximation of the original $Z_{ABC}$ and that the approximated matrix is symmetric, matching the balanced assumption, which the original impedance matrix did not fully comply with. Therefore, is the original $Z_{ABC}$ was reduced assuming a balanced impedance distribution when that was not the case, if we build the approximated matrix, we will never know if it represents the reality.





%-------------------------------------------------------------------------------
%	CHAPTER The branch element
%-------------------------------------------------------------------------------
\chapter{The branch element}

To the effect of most calculations run in operation of a electrical system, the lines, transformers, and any other element that connects two nodes are represented by the so-called $\Pi$ model.


\section{$\Pi$ Model}

\marginnote{In the case of lines, the series admittance $Y_{serie}$ is computed as the inverse of $Z_{ABC}$. From the line's calculation it is obtained the series impedance matrix $Z_{ABC}$ and the shunt admittance matrix $Y_{sh}$. }

The pi model is composed by a series admittance  $Y_{serie}$ and a shunt admittance $Y_{sh}$ divided in two. The shunt admittances are connected at the sending and receiving terminals (primary and secondary). To accommodate the possibility of regulating the voltage at the sending and/or receiving terminals, two per-unit transformers are included as well. The per unit transformers are modelled with the \textit{tap ratio} parameters $\alpha$ and $\beta$.


\begin{center}
	\begin{figure*}[h]
		\includegraphics[width=0.6\linewidth]{img/Branch.eps}
		\caption{General branch model.}
		\label{pi_model}
	\end{figure*}
\end{center}

The generalized admittance matrix that corresponds to the $\Pi$ model is:
\begin{equation}
\left[\begin{array}{c}
I_p \\
I_s
\end{array}\right] = \left[\begin{array}{cc}
Y_{pp} & Y_{ps} \\
Y_{sp} & Y_{ss}
\end{array}\right] \times \left[\begin{array}{c}
V_p \\
V_s
\end{array}\right]
\label{pi_main_formula}
\end{equation}

Where:

\begin{table}[h!]
\begin{center}
\begin{tabular}{cccc}
\toprule

$Y_{pp}$ &  $Y_{ps}$ & $Y_{sp}$ & $Y_{ss}$\\

\midrule

$\frac{Y_{series} + \frac{Y_{sh}}{2}}{\alpha^2}$ &  $\frac{-Y_{series}}{\alpha\beta}$ & $\frac{-Y_{series}}{\alpha\beta}$ & $\frac{Y_{series} + \frac{Y_{sh}}{2}}{\beta^2}$\\

\bottomrule
\end{tabular}
\end{center}
  \caption{Equations of the generalized $\Pi$ model.}
  \label{pi_model_equations}
\end{table}

The formula \ref{pi_main_formula} will be used to compute the network admittance matrices.


\section{Line}

The line element, utilizes the branch model as it has been formulated, only that the use of the tap ratio relations $\alpha$ and $\beta$ is not necessary.


\subsection{Overhead lines}


\subsection{Underground cables}


\paragraph{Example}

Let's assume that we have already computed the series impedance and the shunt admittance of a three-phase line. The nominal voltage at the line terminals is $66kV$ and we choose the base power to be $S_{base}=100MVA$.

$$
Z_{ABC} = \left[ \begin{array}{ccc}
0.4576 + j 1.0780 & 0.1560 + j0 .5017 & 0.1535 + j 0.3849 \\
0.1560 + j 0.5017 & 0.4666 + j 1.0482 & 0.1580 + j 0.4236 \\ 
0.1535 + j 0.3849 & 0.1580 + j 0.4236 & 0.4615 + j 1.0651
\end{array} \right] \Omega
$$

$$
Y_{sh} = \left[ \begin{array}{ccc}
j5.6712 & -j1.8362 & -j0.7034 \\
-j1.8362 & j5.9774 & -j1.1690 \\ 
-j0.7034 & -j1.1690 & j5.3911
\end{array} \right] \cdot 10^{-6}  S
$$

The first thing we need to do is to compute the base magnitudes:

$$
Z_{base} = \frac{100 MVA}{(66kV)^2} = 0.022956841 \quad \Omega
$$

$$
Y_{base} = \frac{1}{Z_{base}} = 43.56 \quad S
$$

Then we must obtain the line series admittance matrix $Y_{series}$ by inverting the 3x3 matrix $Z_{ABC}$. The we divide the resulting matrix by $Y_{base}$. Analogously we can invert the per unit impedance matrix:

$$
Y_{series} = \left(\frac{Z_{ABC}}{Z_{base}}\right)^{-1} \quad p.u.
$$

$$
Y_{series} = \left[ \begin{array}{ccc}
0.0112-j0.0232  & -0.0054+j0.008   & -0.0020+j0.0052 \\ -0.0054+j0.008  &  0.0125-j0.024 & -0.0033+j0.0063 \\ -0.0020+j0.0052 &  -0.0033+j0.0063 & 0.0100-j0.0224
\end{array} \right]\quad  p.u.
$$

Dividing the shunt admittance by the base admittance we obtain the per unit shunt admittance:

$$
Y_{sh} = \left[ \begin{array}{ccc}
j13.0193 & -j4.2153 &  -j1.6148 \\
-j4.2153 & j13.7222 & -j2.6837 \\ 
-j1.6148 & -j2.6837 & j12.3763
\end{array} \right] \cdot 10^{-8}  \quad p.u.
$$

Now we need to find the branch model admittances $Y_{pp}$, $Y_{ps}$, $Y_{sp}$ and $Y_{ss}$.

$$
Y_{pp} = Y_{ss} = Y_{series} + Y_{sh}/2 = \left[ \begin{array}{ccc}
0.0112-j0.0232  & -0.0054+j0.008   & -0.0020+j0.0052 \\ -0.0054+j0.008  &  0.0125-j0.024 & -0.0033+j0.0063 \\ -0.0020+j0.0052 &  -0.0033+j0.0063 & 0.0100-j0.0224
\end{array} \right]\quad  p.u.
$$

$$
Y_{ps} = Y_{sp} = -Y_{series} = \left[ \begin{array}{ccc}
-0.0112+j0.0232  & 0.0054-j0.008   & 0.0020-j0.0052 \\  0.0054-j0.008  &  -0.0125+j0.024 & 0.0033-j0.0063 \\  0.0020-j0.0052 &  0.0033-j0.0063 & -0.0100+j0.0224
\end{array} \right]\quad  p.u.
$$

If we convert the three-phase matrices into positive sequence values we obtain:

$$
Y_{pp} = Y_{ss} = 0.0148 -j0.0296
$$

$$
Y_{ps} = Y_{sp} = -0.0148 +j0.0296
$$


$$
\left[\begin{array}{c}
I_p \\
I_s
\end{array}\right] = \left[\begin{array}{cc}
0.0148 -j0.0296 & -0.0148 +j0.0296\\
-0.0148 +j0.0296 & 0.0148 -j0.0296
\end{array}\right] \times \left[\begin{array}{c}
V_p \\
V_s
\end{array}\right]
$$

\newpage
\section{Transformer}

The transformer model implements the branch model as well, but the model admittances $Y_{pp}$, $Y_{ps}$, $Y_{sp}$ and $Y_{ss}$ vary depending on the connections types at the primary and at the secondary.

The most common transformer connections at the terminals are:

\begin{itemize}
\item Delta ($\Delta$)
\item Wye ($Y$)
\item Grounded Wye (the neutral is grounded) ($Yg$)
\end{itemize}




\begin{table}[h!]\index{typefaces!sizes}
\begin{center}
\begin{tabular}{ccccc}
\toprule
Primary & Secondary & $Y_{pp}$  & $Y_{ss}$ & $Y_{ps}$ and $Y_{sp}$\\
\midrule
 $Yg$ & $Yg$ 			& $\frac{1}{\alpha^2}Y_I$ 				& $\frac{1}{\beta^2}Y_I$ 		& $-\frac{1}{\alpha\beta}Y_I$\\
 $Yg$ & $Y$ 			& $\frac{1}{3\alpha^2}Y_{II}$			& $\frac{1}{3\beta^2}Y_{II}$	& $-\frac{1}{3\alpha\beta}Y_{II}$	\\
 $Yg$ & $\Delta$  		& $\frac{1}{\alpha^2}Y_I$ 				& $\frac{1}{\beta^2}Y_{II}$ 	& $\frac{1}{\alpha\beta}Y_{III}$	 \\
 $Y$ & $Yg$ 			& $\frac{1}{3\alpha^2}Y_{II}$			& $\frac{1}{3\beta^2}Y_{II}$	& $-\frac{1}{3\alpha\beta}Y_{II}$ \\
 $Y$ & $Y$  			& $\frac{1}{3\alpha^2}Y_{II}$			& $\frac{1}{\beta^2}Y_{II}$ 	& $\frac{1}{\alpha\beta}Y_{III}$	 \\
 $\Delta$ & $\Delta$ 	& $\frac{1}{\alpha^2}Y_{II}$			& $\frac{1}{\beta^2}Y_{II}$		& $-\frac{1}{\alpha\beta}Y_{II}$\\
 $\Delta$ & $Yg$ 		& $\frac{1}{\alpha^2}Y_{II}$			& $\frac{1}{\beta^2}Y_{I}$		& $\frac{1}{\alpha\beta}Y_{III}$\\
\bottomrule
\end{tabular}
\end{center}
  \caption{Three-phase transformer impedances of the branch model.}
  \label{transfoemer_impedances_table}
\end{table}

The table \ref{transfoemer_impedances_table} lays out the branch admittances for every pair of connections. The source for this model is the excellent book by J.Arrillaga\cite{arrillaga1990computer}.

\begin{equation}
Y_{I} = \left[ \begin{array}{ccc}
y_t & 0 &  0 \\
0 & y_t & 0 \\ 
0 & 0 & y_t
\end{array} \right] 
\end{equation}

\begin{equation}
Y_{II} = \left[ \begin{array}{ccc}
2y_t & -y_t &  -y_t \\
-y_t & 2y_t & -y_t \\  
-y_t & -y_t & 2y_t
\end{array} \right] 
\end{equation}

\begin{equation}
Y_{III} = \left[ \begin{array}{ccc}
-y_t & y_t &  0 \\
0 & -y_t & y_t \\ 
y_t & 0 & -y_t
\end{array} \right] \newline
\end{equation}


$y_t$ is the transformer winding per unit admittance. It is given in values per units from the transformer specifications sheet. Usually it is given either directly as magnetizing resistance $r_m$ and inductance $x_m$, in which case:

\begin{equation}
y_t = \frac{3}{r_l + jx_l}
\end{equation}

Or it is given as the "short circuit study" values. This is a more complete case.



\subsection{Transformer definition from the short circuit study}

In order to get the series impedance and shunt admittance of the transformer to match the branch model, it is advised to transform the specification sheet values of the device into the desired values. The values to take from the specifications sheet are: \newline
\begin{itemize}
	\item $S_n$: Nominal power in MVA.
	\item $U_{hv}$: Voltage at the high-voltage side in kV.
	\item $U_{lv}$: Voltage at the low-voltage side in kV.
	\item $U_{sc}$: Short circuit voltage in \%.
	\item $P_{cu}$: Copper losses in kW.
	\item $I_0$: No load current in \%.
	\item $GX_{hv1}$: Reactance contribution to the HV side. Value from 0 to 1.
	\item $GR_{hv1}$: Resistance contribution to the HV side Value from 0 to 1.\newline
\end{itemize}

Then, the series and shunt impedances are computed as follows:

\begin{multicols}{2}
Nominal impedance HV (Ohm): 
\begin{equation}
Zn_{hv} = U_{hv}^2 / S_n
\end{equation}


Nominal impedance LV (Ohm): 
\begin{equation}
Zn_{lv} = U_{lv}^2 / S_n
\end{equation}

Short circuit impedance (p.u.): 
\begin{equation}
z_{sc} = U_{sc} / 100
\end{equation}

Short circuit resistance (p.u.): 
\begin{equation}
r_{sc} = \frac{P_{cu} / 1000}{S_n}
\end{equation}

Short circuit reactance (p.u.):
\begin{equation}
x_{sc} = \sqrt{z_{sc}^2 - r_{sc} ^2}
\end{equation}


HV resistance (p.u.):
\begin{equation}
r_{cu,hv} = r_{sc} \cdot GR_{hv1}
\end{equation}

LV resistance (p.u.): 
\begin{equation}
r_{cu,lv} = r_{sc} \cdot (1 - GR_{hv1})
\end{equation}

HV shunt reactance (p.u.): 
\begin{equation}
xs_{hv} = x_{sc} \cdot GX_{hv1}
\end{equation}

LV shunt reactance (p.u.): 
\begin{equation}
xs_{lv} = x_{sc} \cdot (1 - GX_{hv1})
\end{equation}

Shunt resistance (p.u.): 
\begin{equation}
r_{fe} = \frac{Sn}{P_{fe} / 1000}
\end{equation}

Magnetization impedance (p.u.):
\begin{equation}
z_m = \frac{1}{I_0 / 100}
\end{equation}

Magnetization reactance (p.u.):
\begin{equation}
x_m = \frac{1}{\sqrt{\frac{1}{z_m^2} - \frac{1}{r_{fe}^2}}}
\end{equation}

If the content of the square root is negative, set the magnetization impedance to zero.\\


The final complex calculated parameters in per unit are:

Magnetizing impedance (or series impedance): 
\begin{equation}
z_{series} = Z_m = r_{sc} +j \cdot x_{sc}
\end{equation}

The series admittance is [p.u.]: 
\begin{equation}
y_{series} = \frac{1}{z_{series}}
\end{equation}

Leakage impedance (or shunt impedance): 
\begin{equation}
Z_l = r_{fe} + j \cdot x_{m}
\end{equation}

Shunt admittance [p.u.]: 
\begin{equation}
y_{shunt} = 1 / Z_l
\end{equation}


The series admittance for the three-phase model [p.u.]: 
\begin{equation}
y_{t} = \frac{3}{z_{series}}
\end{equation}
\end{multicols}

\marginnote{we divide the impedance by 3, to reflect the three phases.}


\paragraph{Example}

Let's consider a distribution transformer with the following nameplate characteristics:


\begin{multicols}{2}
\begin{itemize}
\item Primary connection: $\Delta$
\item Secondary connection: $Yg$
\item $S_n = 0.5 MVA$
\item $U_{hv} = 20  kV$
\item $U_{lv} = 0.4 kV$

\item $U_{sc} = 6  \%$
\item $p_{cu} = 6  kW$
\item $p_{fe} = 1.4 kW$
\item $I_0 = 0.28 \%$

\item $GR_{hv} = 0.5$
\item $GX_{hv} = 0.5$
\end{itemize}
\end{multicols}


First we obtain the impedance value, from the short circuit study:
\begin{multicols}{2}
$$Zn_{hv} =  800 \quad \Omega$$
$$Zn_{lv} =  0.3200 \quad \Omega$$
$$z_{sc} =  0.0600 \quad p.u.$$
$$r_{sc} =  0.0120 \quad p.u.$$
$$x_{sc} =  17.0103 \quad p.u.$$
$$r_{cu,hv} =  0.0060 \quad p.u.$$
$$r_{cu,lv} =  0.0060 \quad p.u.$$
$$x_{s,hv} =  8.5052 \quad p.u.$$
$$x_{s,lv} =  8.5052 \quad p.u.$$
$$r_{fe} =  357.1429 \quad p.u.$$
$$z_m =  357.1429 \quad p.u.$$
$$x_m =  24296003999.8084 \quad p.u.$$
$$z_{series} =  0.0120 + j17.0103 \quad p.u.$$
$$y_{series} =  0.0000 - j0.0588 \quad p.u.$$
$$y_{shunt} =  0.0000 - j0.0000 \quad p.u.$$
$$y_t =  0.0001 - j0.1764 \quad p.u.$$
\end{multicols}

Once the we have obtained the $y_t$ value, we start building the appropriate branch impedance matrices $Y_{pp}$, $Y_{ps}$, $Y_{sp}$ and $Y_{ss}$.
$$
Y_{I} = \left[\begin{array}{ccc}
0.0001 - j0.1764 & 0.0000 + j0.0000 & 0.0000 + j0.0000 \\
0.0000 + j0.0000 & 0.0001 - j0.1764 & 0.0000 + j0.0000 \\
0.0000 + j0.0000 & 0.0000 + j0.0000 & 0.0001 - j0.1764
\end{array} \right]
$$


$$
Y_{II} = \left[ \begin{array}{ccc}
0.0002 - j0.3527 & -0.0001 + j0.1764 & -0.0001 + j0.1764\\
-0.0001 + j0.1764 & 0.0002 - j0.3527 & -0.0001 + j0.1764\\
-0.0001 + j0.1764 & -0.0001 + j0.1764 & 0.0002 - j0.3527
\end{array} \right]
$$

$$
Y_{III} = \left[ \begin{array}{ccc}
-0.0001 + j0.1764 & 0.0001 - j0.1764 & 0.0000 + j0.0000\\
0.0000 + j0.0000 & -0.0001 + j0.1764 & 0.0001 - j0.1764\\
0.0001 - j0.1764 & 0.0000 + j0.0000 & -0.0001 + j0.1764
\end{array} \right]
$$


According to the transformer $\Delta \rightarrow Yg$ connection, we build the branch model admittances using the formulas for the table \ref{transfoemer_impedances_table}:

$$
Y_{pp} =\left[ \begin{array}{ccc}
0.0002 - j0.3527 & -0.0001 + j0.1764 & -0.0001 + j0.1764\\
-0.0001 + j0.1764 & 0.0002 - j0.3527 & -0.0001 + j0.1764\\
-0.0001 + j0.1764 & -0.0001 + j0.1764 & 0.0002 - j0.3527
\end{array} \right]
$$


$$
Y_{ss} =\left[ \begin{array}{ccc}
0.0001 - j0.1764 & 0.0000 + j0.0000 & 0.0000 + j0.0000\\
0.0000 + j0.0000 & 0.0001 - j0.1764 & 0.0000 + j0.0000\\
0.0000 + j0.0000 & 0.0000 + j0.0000 & 0.0001 - j0.1764
\end{array} \right]
$$


\marginnote{There is no computational need to assemble the 6x6 element impedance matrix in a computer program. The branch model matrices are added to the full circuit matrix instead.}

$Y_{ps} = Y_{sp} =$
$$
\left[ \begin{array}{ccc}
-0.0001 + j0.1764 & 0.0001 - j0.1764 & 0.0000 + j0.0000\\
0.0000 + j0.0000 & -0.0001 + j0.1764 & 0.0001 - j0.1764\\
0.0001 - j0.1764 & 0.0000 + j0.0000 & -0.0001 + j0.1764
\end{array} \right]
$$





\section{Voltage regulator}

Since all the electrical models are in per-unit values, the voltage regulator is modelled in the exact same way as a transformer.




%-------------------------------------------------------------------------------
%	CHAPTER The bus and it's connected elements
%-------------------------------------------------------------------------------
\chapter{The bus and it's connected elements}


\section{The substation}



\section{Types of buses}


\section{Load}


\section{Voltage controlled generator}


\section{Battery}


\section{Capacitor banks}




%-------------------------------------------------------------------------------
%	CHAPTER Topology analysis and consolidation
%-------------------------------------------------------------------------------
\chapter{Topology analysis and consolidation}


\section{Islands detection}


\section{Calculation of the bus connected phases}


\section{Calculation of the admittance matrices}


\section{Calculation of the voltage, power and current vectors}


%-------------------------------------------------------------------------------
%	CHAPTER Power flow
%-------------------------------------------------------------------------------
\chapter{Power flow}

The power flow problem consists in finding the node voltages that correspond to the injected current and power values. The fundamental equation to be solved is:

\begin{equation}
S = V \times (Y \times V - I)^*
\label{eq:power_flow}
\end{equation}

\marginnote{Note that the equation \ref{eq:power_flow} is non-linear when solving for the voltage ($V$). However if there are no power injections and only current injections, the equation becomes linear. Because of the non-linearity, we will be using iterative methods to solve this equation.}

Where:

\begin{itemize}
\item $S$: Vector of power injections.
\item $I$: Vector of current injections.
\item $V$: Vector of voltages.
\item $Y$: Admittance matrix.
\end{itemize}




\section{Z-Matrix}

The Z-Matrix method is a simple iterative method that provides good results, especially in distribution grids where the voltage variations are not large.

The Z-Matrix method requires the Kron reduction of the slack nodes of the circuit. This reduction is explained below:

\begin{figure}[h!]
  \includegraphics[width=\linewidth]{img/Matrix_reduction.eps}
  \caption{Circuit's admittance matrix and vectors reduction. Representation for a six node circuit with two slack nodes.}
  \label{fig:reduction}
\end{figure}

\begin{equation}
Y_{red} = Y[pqpv, pqpv]
\end{equation}

\begin{equation}
Y_{slack} = Y[pqpv, vd]
\end{equation}

\begin{equation}
V_{red} = V[pqpv]
\end{equation}

\begin{equation}
V_{slack} = V[vd]
\end{equation}

\begin{equation}
S_{red} = S[pqpv]
\end{equation}

\begin{equation}
I_{red} = I[pqpv]
\end{equation}


Once we have all the reduced magnitudes, it means that we have removed the slack (VD) nodes from the circuit, but we must keep their influence in the rest of the nodes in the form of current injections.

First we copy $V_{red}$ into another variable $V_{prev}$.

\begin{equation}
V_{prev} = V_{red}
\end{equation}

The current injections appearing by the removal of the slack nodes are:
\begin{equation}
I_{slack} = Y_{slack} \times V_{slack}
\end{equation}

The voltages that arise from the slack current injections are:
\begin{equation}
C_k = Y_{red} \times I_{slack}
\end{equation}

The total injected currents including the power injections are:
\begin{equation}
I_k = \frac{S_{red}}{V_{prev}} + I_{red}
\label{eq:zm_ik}
\end{equation}

The next step is to compute the nodes voltage due to all the power and current injections:

\begin{equation}
V_k = Y_{red}^{-1} \times I_k - C_k
\end{equation}

Now the error is the infinite norm of the voltage difference.

\begin{equation}
error = ||V_{prev} - V_k ||_{\infty} = max(abs(V_{prev} - V_k ))
\end{equation}

The infinite norm of the voltage difference between the previous iteration and the current iteration is a poor convergence criteria, but it is usually the only working criteria in practice for this method.

Next, we copy the voltage solution to the previous voltage solution vector:

\begin{equation}
V_{prev} = V_k
\label{eq:zm_copy_sol}
\end{equation}

Repeat equations \ref{eq:zm_ik} to \ref{eq:zm_copy_sol} until the error is less or equal to a given tolerance not too strict like $1\times10^{-3}$.

Finally, since we have found the voltages for the PQ and PV nodes only, we should return a voltage vector with the voltages for all the nodes. Because of this, we copy the voltage solution for the reduced system into a copy of the original voltage vector.

\begin{equation}
V[pqpv] = V_k
\end{equation}


\section{Jacobian based power flow}

The derivative based methods are more accurate than the derivative free methods. They are usually more robust at the cost of being more computationally expensive. In this section we'll start by introducing the Jacobian matrix, which is the system derivative for a certain set of voltage values and then we'll introduce the methods that use this matrix to solve the power flow problem.

\begin{center}
\begin{figure}[h!]
  \includegraphics[width=0.9\linewidth]{img/JacobianBased.eps}
  \caption{Jacobian based linear system to compute the voltage increments.}
  \label{fig:jacobian_based}
\end{figure}
\end{center}



\subsection{Building the Jacobian matrix} \label{Jacobian_chapter}

The Jacobian matrix ($J$) is the derivative of the fundamental power flow equation \ref{eq:power_flow}, with respect to the voltage magnitudes to be solved $|V|$ and $\delta$. It is one of the most expensive parts of the derivative based power flow methods.

In most literature, the reader will find the Jacobian presented with non matrix formulas which are hard to understand in their relation to the Jacobian matrix formation. Ray D. Zimmerman came up with a fantastic way of building the Jacobian matrix \cite{zimmerman2010ac} by using lineal algebra operations over the complex matrices and vectors that represent the circuit. The formulation presents a huge advantage: No use of cosine and sine operations for the derivatives computation. The calculation of trigonometric functions is a recursive operation and should be avoided whenever possible in high performance computing. The formulation is presented as follows.

First we compute the total current injection. It is a sparse diagonal matrix, so do not use a dense matrix format.
\begin{equation}
I_{diag} = diag(Y \times V - I)
\end{equation}

Then we convert the buses voltage solution $V$ into a square diagonal matrix. Use a sparse format for this.
\begin{equation}
V_{diag} = diag(V)
\end{equation}

Compute the buses voltage normalized solution $V$ into a square diagonal matrix. This is acomplished by dividing each complex voltage by its absolute value. Use a sparse format for this.
\begin{equation}
E_{diag} = diag(V / |V|)
\end{equation}

Now, Compute the derivative of the power injections $S$ with respect to the voltage module $|V|$:
\begin{equation}
\frac{\partial S}{\partial |V|} = V_{diag} \times (Y \times E_{diag})^* + I_{diag}^* \times  E_{diag}
\end{equation}
    
Compute the derivative of the power injections $S$ with respect to the voltage angle $\delta$:
\begin{equation}
\frac{\partial S}{\partial \delta} = 1j \cdot V_{diag} \times (I_{diag} - Y \times V_{diag})^*
\end{equation}

Finally, assemble the Jacobian matrix $J$. The Jacobian matrix is sparse and only contains real values. If the circuit contains $npq$ buses of type $PQ$ and $npv$ buses of type $PV$, the Jacobian matrix is a square matrix with $2 npq + npv$ rows and the same number of columns. See the figure \ref{fig:jacobian_based}.

\begin{equation}
J=
\left[
\begin{array}{cc}
real\left(\frac{\partial S}{\partial \delta}[pqpv, pqpv]\right) &
real\left(\frac{\partial S}{\partial |V|}[pqpv, pq]\right) \\
imag\left(\frac{\partial S}{\partial \delta}[pq, pqpv]\right) &
imag\left(\frac{\partial S}{\partial |V|}[pq, pq]\right)
\end{array}
\right]
\end{equation}

Observe that the Jacobian matrix is composed of four subsets of the previously computed derivatives $\frac{\partial S}{\partial \delta}$ and $\frac{\partial S}{\partial |V|}$, where combinations of the $PQ$ and $PV$ node indices are selected.

$pqpv$ is a vector that contains the indices of the $PQ$ and $PV$ type indices in sequential order.

$pq$ is a vector that contains the indices of the $PQ$  type indices in sequential order.

\newpage
\subsection{Newton-Raphson}

Newton-Raphson is a recursive, iterative numerical method that minimizes the value of a function. In our case the value to minimize is the power mismatch:

\begin{equation}
s_{calc} = V \times (Y \times V - I_{bus})^*
\label{eq:nr_Scalc}
\end{equation}

\begin{equation}
\Delta S = S_{specified} - S_{calc} 
\end{equation}


Since the mismatch ($\Delta S$) is a vector of complex values, we transform it into a vector ($F$) with the real part of $\Delta S$ for the PQ and PV bus indices and the imaginary part of $\Delta S$ for the PQ bus indices of the vector. Observe that the length of the vector is $2npq+npv$, matching the Jacobian dimensions.



\begin{equation}
F =  \left[
\begin{array}{c}
\Delta P \\
\Delta Q  
\end{array}
\right]
\label{eq:nr_mismatch}
\end{equation}

\begin{equation}
\Delta Q = imag(\Delta S[pq]) 
\label{eq:nr_q_inc}
\end{equation}

\begin{equation}
\Delta P = real(\Delta S[pqpv])
\label{eq:nr_p_inc}
\end{equation}

Then we define the error to minimize as the infinite norm of $F$. The infinite norm is the same as the maximum absolute value. If the error is less than the specified tolerance, we stop the iterations otherwise, continue until a certain number of iterations considered as the maximum (for example 20).

\begin{equation}
error = ||F||_{\infty} = max(abs(F))
\label{eq:nr_error}
\end{equation}

If the error is higher than the tolerance, we need to solve the voltages increment ($\Delta x$), for which we must compute the Jacobian first. Some simplifications of the method only compute the Jacobian one time, but for better accuracy, the Jacobian needs to be calculated on every iteration.

\begin{equation}
\Delta x = J^{-1} \times F
\label{eq:nr_solve}
\end{equation}

Notice that $\Delta x$ is a vector with the voltage angles ($\delta$) for the PQ and PV nodes followed by the voltage modules ($|V|$) for the PQ nodes. This matches the way we built the Jacobian ($J$) and the mismatch ($F$). Now we must assign those polar voltage angle and module increments to the rectangular voltage vector that we use to compute the Jacobian and the mismatch.

To accomplish this, we declare two polar voltage increment vectors $\Delta |V|$ and $\Delta \delta$, initialize them to zero, and we fill the corresponding values with the following:

\marginnote{Here we use the auxiliary vectors $pqpv$ and $pq$ which contain the indices of the pq and pv type buses, and the pq type buses respectively. $npqpv$ and $npq$ are the sizes of those two vectors.}
\begin{equation}
\Delta \delta[pqpv[i]] = \Delta x[i]  \quad \forall i \in {0..npqpv}
\label{eq:nr_dd1}
\end{equation}

\begin{equation}
\Delta  |V|[pq[i]] = \Delta x[i+npqpv]  \quad \forall i \in {0..npq}
\end{equation}

Then we need to add those values to the voltage module and angle vectors $|V|$ and $\delta$:

\marginnote{Here we introduce the notion of the $k_{th}$ iteration wich represents the current iteration and the $k_{th}+1$ represents the next iteration.}

\begin{equation}
|V|^{(k+1} = |V|^{(k} + \Delta |V|^{(k}
\end{equation}

\begin{equation}
\delta^{(k+1} = \delta^{(k} + \Delta \delta^{(k}
\end{equation}

At last, we convert the polar vectors  $|V|$ and $\delta$ into a single complex voltage vector $V$.

\begin{equation}
V^{(k+1} = |V|^{(k+1} \cdot \left( cos(\delta^{(k+1}) + 1j \cdot sin(\delta^{(k+1})\right)
\label{eq:nr_voltage_conversion}
\end{equation}

The method consists in repeating formulas \ref{eq:nr_Scalc} to \ref{eq:nr_voltage_conversion} until the error is less or equal to the tolerance or a number of iterations is reached.

The algorithm is then:

\begin{enumerate}

\item Start.

\item Compute the mismatch function ($F$) using the initial voltage solution ($V$). Equation \ref{eq:nr_mismatch}.

\item Compute the error. Equation \ref{eq:nr_error}.

\item While $error > tolerance$ or $iterations < max\_iterations$:

	\begin{enumerate}
	\item Compute the Jacobian
	
	\item Solve the linear system. Equation \ref{eq:nr_solve}.
	
	\item Assign $\Delta x$ to $V$. Equations \ref{eq:nr_dd1} to \ref{eq:nr_voltage_conversion}.
	
	\item Compute the mismatch function ($F$) using the latest voltage solution ($V$). Equation \ref{eq:nr_mismatch}.
	
	\item Compute the error. Equation \ref{eq:nr_error}.
	
	\item $iterations = iterations + 1$
	\end{enumerate}

\item End.
\end{enumerate}



\newpage
\subsection{Levenberg-Marquardt}

The Levenbarg-Marquardt is a recursive and iterative technique that is usually not related to power flow, but rather to non-linear least squares problems. Nevertheless, it solves the exact same problem as Newton-Raphson, but in a much more robust manner. It is advised when Newton-Raphson does not converge, because it exhibits excellent convergence properties at the cost of a higher computational effort.


At each iteration we need to assemble the system matrix $A$ as follows:
%    // system matrix
%    H1 = H.t();
%
%    // H2 = H1 x H
%    H2 = H1 * H;
%
%    // set first value of lmbda
%    if (iter == 0)
%        lbmda = 1e-3 * H2.diag().max();
%
%    // compute system matrix A = H^T·H - lambda·I
%    A = H2 + lbmda * Idn;


\begin{equation}
A = J^T \times J + \lambda \cdot I
\label{eq:lm_A}
\end{equation}

Where $\lambda$ is computed only in the first iteration as:

\begin{equation}
\lambda = 0.001 \cdot max(diag(J \times J^T))
\end{equation}

The right hand side of the linear system to obtain the voltage increments is:

\marginnote{$F$ is provided in the equation \ref{eq:nr_mismatch}.}

\begin{equation}
rhs = J^T \times F
\label{eq:lm_rhs}
\end{equation}


Solve the voltage increments vector $\Delta x$. As in Newton-Raphson, this vector has $2npq+npv$ elements and the structure is the same as the one explained in the Newton-Raphson method. See figure \ref{fig:jacobian_based}.

\begin{equation}
\Delta x = A^{-1} \times rhs
\label{eq:lm_solve}
\end{equation}

Compute the objective function to minimize $f$. It is a value.

\begin{equation}
f = \frac{1}{2} \cdot (F \times F^T)
\label{eq:lm_f}
\end{equation}

Calculate the decision function $\rho$. It is a value.

\marginnote{$f^{(k-1}$ is the value of $f$ in the previous iteration. $f^{(k}$ is the value of $f$ computed in the current iteration. The value of  $f^{(k-1}$  in the first iteration should be a very large number  i.e. $1 \times 10^9$.}

\begin{equation}
\rho = \frac{f^{(k-1}-f^{(k}}{\frac{1}{2} \cdot (\Delta x \times (\lambda \cdot \Delta x + rhs)^T)}
\label{eq:lm_rho}
\end{equation}

Now, based on the value of $\rho$ we decide what to do in the next iteration.

If $\rho$ is greater than zero, we mark a flag to update the Jacobian in the next iteration, and we update the voltage solution using $\Delta x$ as described in equations Equations \ref{eq:nr_dd1} to \ref{eq:nr_voltage_conversion}. We also need to modify $\lambda$:


\begin{equation}
\lambda = \lambda \cdot max(\frac{1}{3}, 1-(2\cdot \rho -1)^3)
\label{eq:lm_update_l}
\end{equation}

And set a variable $\nu=2$ .


If $\rho$ is less or equal to zero, then the values of $\Delta x$ will not improve the solution and we need to take corrective actions. We mark a flag to not to update the Jacobian in the next iteration, we set $\lambda=\lambda \cdot \nu$ and $\nu = \nu \cdot 2$.


The complete algorithm is: 

\begin{enumerate}

\item Start.

\item Compute the mismatch function ($F$) using the initial voltage solution ($V$). Equation \ref{eq:nr_mismatch}.

\item Compute the error. Equation \ref{eq:nr_error}.

\item While $error > tolerance$ or $iterations < max\_iterations$:

	\begin{enumerate}
	\item If the computation of the Jacobian is enabled, compute the Jacobian and the system matrix $A$ using equation \ref{eq:lm_A}.
	
	\item Compute the linear system right hand side using equation \ref{eq:lm_rhs}.
	
	\item Solve the linear system to obtain $\Delta x$. Equation \ref{eq:lm_solve}.
	
	\item Compute the objective function $f$ using equation \ref{eq:lm_f}.
	
	\item Compute the decision value $\rho$ using equation \ref{eq:lm_rho}.
	
	\item If $\rho > 0$:
	
		\begin{enumerate}
		\item Assign $\Delta x$ to $V$. Equations \ref{eq:nr_dd1} to \ref{eq:nr_voltage_conversion}.
		
		\item Update $\lambda$ using equation \ref{eq:lm_update_l}.
		
		\item Set $\nu = 2$.
		
		\item Set the Jacobian update flag to true.
		\end{enumerate}
		
	\item If $\rho \leq 0$:
	
		\begin{enumerate}
		\item Assign $\Delta x$ to $V$. Equations \ref{eq:nr_dd1} to \ref{eq:nr_voltage_conversion}.
		
		\item Update $\lambda = \nu \cdot \lambda$.
		
		\item Update $\nu = 2 \cdot \nu$.
		
		\item Set the Jacobian update flag to false.
		\end{enumerate}
	
	\item Compute the mismatch function ($F$) using the latest voltage solution ($V$). Equation \ref{eq:nr_mismatch}.
	
	\item Compute the error. Equation \ref{eq:nr_error}.
	
	\item $iterations = iterations + 1$
	\end{enumerate}

\item End.
\end{enumerate}



\section{Holomorphic embedding}


\section{Post voltage solution: Compute the power flows}

Ironically, what is called the power flow problem does not compute the power flows in the branches of a grid. It computes the node voltages. In this section we explain how to compute the current and power that flows through the grid branches upon a given voltage solution vector.

%-------------------------------------------------------------------------------
%	CHAPTER Time series power flow
%-------------------------------------------------------------------------------
\chapter{Time series power flow}



%-------------------------------------------------------------------------------
%	CHAPTER Stochastic power flow
%-------------------------------------------------------------------------------
\chapter{Stochastic power flow}

\section{Cumulative Density Function (CDF)}


\section{Monte Carlo}


\section{Latin Hypercube}




%-------------------------------------------------------------------------------
%	CHAPTER State estimation
%-------------------------------------------------------------------------------
\chapter{State estimation}



%-------------------------------------------------------------------------------
%	CHAPTER Short-circuit
%-------------------------------------------------------------------------------
\chapter{Short-circuit}





\backmatter

\bibliography{bibliography}
\bibliographystyle{plainnat}


\printindex

\end{document}